{% extends 'base.html' %}
{% block content %}

<link rel="stylesheet" href="{{ url_for('static', filename='css/chessboard.css') }}">
<style>
  /* Custom board styling */
  #board {
    width: 100%;
    max-width: 520px;
    margin: 0 auto;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  
  /* Improve board appearance */
  .board-b72b1 {
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.1);
    overflow: hidden;
  }
  
  /* Better square colors */
  .white-1e1d7 {
    background-color: #f0d9b5 !important;
  }
  
  .black-3c85d {
    background-color: #b58863 !important;
  }
  
  /* Highlight colors */
  .highlight1-32417, .highlight2-9c5d2 {
    box-shadow: inset 0 0 3px 3px rgba(56, 189, 248, 0.8) !important;
  }

  /* Tap-to-move helpers */
  #board.board-blocked {
    pointer-events: none;
  }

  .square-55d63 {
    position: relative;
    box-shadow: var(--sq-shadow-1, none), var(--sq-shadow-2, none);
  }

  .square-55d63.board-square-selected {
    --sq-shadow-2: inset 0 0 0 4px rgba(56, 189, 248, 0.75);
  }

  .square-55d63.board-square-lastmove {
    --sq-shadow-1: inset 0 0 0 4px rgba(245, 158, 11, 0.55);
  }

  .square-55d63.board-square-hint {
    --sq-shadow-1: inset 0 0 0 4px rgba(34, 197, 94, 0.55);
  }

  .square-55d63.board-square-legal::after,
  .square-55d63.board-square-legal-capture::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-radius: 999px;
    pointer-events: none;
  }

  .square-55d63.board-square-legal::after {
    width: 14px;
    height: 14px;
    background: rgba(56, 189, 248, 0.35);
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.25);
  }

  .square-55d63.board-square-legal-capture::after {
    width: 22px;
    height: 22px;
    background: transparent;
    border: 3px solid rgba(56, 189, 248, 0.55);
   }
  
  /* Best moves badge styling */
  .best-moves-container {
    background: rgba(15, 23, 42, 0.6);
    border-radius: 8px;
    padding: 10px;
    margin-top: 15px;
  }
  
  .best-move-badge {
    display: inline-block;
    background: linear-gradient(135deg, rgba(56, 189, 248, 0.2), rgba(168, 85, 247, 0.2));
    border: 1px solid rgba(56, 189, 248, 0.3);
    padding: 4px 12px;
    border-radius: 20px;
    margin: 2px;
    font-family: monospace;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .best-move-badge:hover {
    background: linear-gradient(135deg, rgba(56, 189, 248, 0.4), rgba(168, 85, 247, 0.4));
    transform: translateY(-1px);
  }
</style>

{% if errors %}
<div class="alert alert-danger">
  <strong>‚ö†Ô∏è Errors</strong>
  <ul class="mb-0">
    {% for err in errors %}
    <li>{{ err }}</li>
    {% endfor %}
  </ul>
</div>
{% endif %}

{% if processing %}
<div class="alert alert-info">
  <div class="spinner-border spinner-border-sm me-2"></div>
  Analysis in progress... Page will refresh when complete.
  <button class="btn btn-sm btn-outline-info ms-2" onclick="location.reload()">Refresh Now</button>
</div>
{% endif %}

{% if not mistakes %}
<div class="alert alert-light border text-center p-5">
  <h1 class="display-4">üìä</h1>
  <h2 class="mt-3">No Analysis to Display</h2>
  <p class="lead text-muted">
    This is where your opening mistakes will appear after you upload your games and run an analysis.
  </p>
  <hr class="my-4">
  <p>Ready to get started? Go to the training page to begin.</p>
  <a href="{{ url_for('train') }}" class="btn btn-primary btn-lg">
    <i class="fas fa-arrow-right me-2"></i> Go to Training
  </a>
</div>
{% else %}

<!-- Header -->
<div class="card mb-4" style="background: linear-gradient(135deg, rgba(15, 23, 42, 0.9), rgba(30, 41, 59, 0.9)); border: 1px solid rgba(255,255,255,0.1);">
  <div class="card-body d-flex justify-content-between align-items-center flex-wrap gap-3">
    <div>
      <h2 class="mb-1 d-flex align-items-center gap-2">
        üéØ Opening Trainer{% if color %} ¬∑ {{ color|title }}{% endif %}
        <span class="badge bg-success">Ready to Train</span>
      </h2>
      <p class="text-muted mb-0">Replay your mistakes and master engine suggestions through active training.</p>
    </div>
    <div class="d-flex gap-2 align-items-center">
      <button class="btn btn-outline-secondary btn-sm" onclick="showStats()">üìä Stats</button>
      <button class="btn btn-outline-primary btn-sm" id="quizToggleBtn" onclick="toggleQuizMode()">üß© Quiz</button>
      <button class="btn btn-outline-secondary btn-sm" data-bs-toggle="modal" data-bs-target="#settingsModal">‚öôÔ∏è Settings</button>
      <div class="text-end ms-3">
        <div class="badge bg-primary">‚â• {{ threshold_cp or 100 }} cp</div>
        <div class="text-muted small">Depth: {{ opening_plies_limit or 20 }} plies</div>
      </div>
    </div>
  </div>
</div>

<!-- Main Content -->
<div class="row g-4">
  <!-- Board Section -->
  <div class="col-lg-6">
    <div class="card" style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(255,255,255,0.1);">
      <div class="card-body">
        <!-- Board Container -->
        <div id="board" style="width: 100%;"></div>
        <div class="d-flex justify-content-between align-items-center mt-2 flex-wrap gap-2">
          <div class="d-flex align-items-center gap-2 flex-wrap">
            <span id="modeBadge" class="badge bg-info">Trainer</span>
            <div id="boardStatus" class="text-muted small">Click/tap a piece, then click/tap a target square.</div>
          </div>
          <div id="quizHud" class="text-muted small d-none">
            Score: <span id="quizCorrect">0</span>/<span id="quizTotal">0</span>
          </div>
          <div class="text-muted small d-none d-md-block"><kbd>H</kbd> hint ¬∑ <kbd>R</kbd> reset ¬∑ <kbd>Esc</kbd> clear</div>
        </div>
        
        <!-- Best Moves Display -->
        <div class="best-moves-container">
          <div class="text-muted small mb-2">üëë Best Moves (Click to Preview)</div>
          <div id="bestMovesDisplay"></div>
        </div>
        
        <!-- Navigation -->
        <div class="btn-group w-100 mt-3" role="group">
          <button type="button" class="btn btn-outline-secondary" id="btnFirst" onclick="firstPosition()" title="First (Home)">‚èÆ</button>
          <button type="button" class="btn btn-outline-secondary" id="btnPrev" onclick="prevPosition()" title="Previous (‚Üê)">‚óÄ</button>
          <button type="button" class="btn btn-outline-secondary flex-grow-1" disabled>
            <span id="posCounter">Position 1</span>
          </button>
          <button type="button" class="btn btn-outline-secondary" id="btnNext" onclick="nextPosition()" title="Next (‚Üí)">‚ñ∂</button>
          <button type="button" class="btn btn-outline-secondary" id="btnLast" onclick="lastPosition()" title="Last (End)">‚è≠</button>
        </div>
        
        <!-- Controls -->
        <div class="row g-2 mt-3">
          <div class="col-6">
            <button class="btn btn-outline-secondary w-100 btn-sm" onclick="flipBoardFunc()">üîÑ Flip</button>
          </div>
          <div class="col-6">
            <button class="btn btn-outline-secondary w-100 btn-sm" onclick="copyFEN()">üìã FEN</button>
          </div>
          <div class="col-6">
            <button class="btn btn-outline-primary w-100 btn-sm" onclick="showHint()" title="Hint (H)">üí° Hint</button>
          </div>
          <div class="col-6">
            <button class="btn btn-outline-secondary w-100 btn-sm" onclick="resetPosition()" title="Reset (R)">‚Ü© Reset</button>
          </div>
          <div class="col-12">
            <a id="lichessLink" class="btn btn-outline-secondary w-100 btn-sm" href="#" target="_blank" rel="noopener">üîó Analyze current position</a>
          </div>
          <div class="col-12">
            <button class="btn btn-outline-danger w-100 btn-sm" onclick="deleteCurrentMistake()">‚úÖ Mark as mastered (remove)</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mistakes List Section -->
  <div class="col-lg-6">
    <div class="card" style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(255,255,255,0.1);">
      <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">üìã Mistake List <span id="mistakeCount" class="badge bg-primary">{{ mistakes|length }}</span></h5>
        <div>
          <button class="btn btn-outline-secondary btn-sm" onclick="exportMistakes()">üì§ Export</button>
          <button class="btn btn-outline-secondary btn-sm" onclick="printMistakes()">üñ®Ô∏è Print</button>
        </div>
      </div>
      <div class="card-body p-0" style="max-height: 550px; overflow-y: auto;">
        <table class="table table-sm table-hover table-striped mb-0" style="background: transparent;">
          <thead style="position: sticky; top: 0; background: rgba(15, 23, 42, 0.95); z-index: 10;">
            <tr>
              <th style="width: 40px;">#</th>
              <th>FREQ</th>
              <th>CP</th>
              <th>MOVE</th>
              <th>SEVERITY</th>
              <th>ACTIONS</th>
            </tr>
          </thead>
          <tbody id="mistakesTableBody">
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script src="{{ url_for('static', filename='js/jquery-3.6.0.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chess.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chessboard.js') }}"></script>

<!-- Settings Modal -->
<div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="settingsModalLabel">‚öôÔ∏è Training Settings</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row g-4">
          <div class="col-md-6">
            <h6 class="mb-3">Board</h6>
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="settingEnableDrag">
              <label class="form-check-label" for="settingEnableDrag">Enable drag &amp; drop</label>
            </div>
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="settingShowCoords">
              <label class="form-check-label" for="settingShowCoords">Show coordinates</label>
            </div>
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="settingHighlightMoves">
              <label class="form-check-label" for="settingHighlightMoves">Show legal move hints</label>
            </div>
          </div>

          <div class="col-md-6">
            <h6 class="mb-3">Trainer</h6>
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="settingAutoAdvance">
              <label class="form-check-label" for="settingAutoAdvance">Auto-advance after correct move</label>
            </div>
            <div class="mb-3">
              <label class="form-label" for="settingAcceptTopN">Accept top moves (N)</label>
              <input type="number" class="form-control" id="settingAcceptTopN" min="1" max="5" step="1">
              <div class="form-text">1 = only the best move, 3 = any of the top 3.</div>
            </div>
            <div class="row g-2">
              <div class="col-6">
                <label class="form-label" for="settingMinCp">Min CP loss</label>
                <input type="number" class="form-control" id="settingMinCp" min="0" step="10">
              </div>
              <div class="col-6">
                <label class="form-label" for="settingMinFreq">Min frequency</label>
                <input type="number" class="form-control" id="settingMinFreq" min="1" step="1">
              </div>
            </div>
          </div>

          <div class="col-12">
            <hr style="border-color: var(--border);">
            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
              <div>
                <h6 class="mb-1">Quiz Mode</h6>
                <div class="text-muted small">Hide best moves and track your score while reviewing positions.</div>
              </div>
              <div class="d-flex gap-3 flex-wrap align-items-center">
                <div class="form-check form-switch mb-0">
                  <input class="form-check-input" type="checkbox" id="settingQuizMode">
                  <label class="form-check-label" for="settingQuizMode">Enable quiz</label>
                </div>
                <div class="form-check form-switch mb-0">
                  <input class="form-check-input" type="checkbox" id="settingQuizShuffle">
                  <label class="form-check-label" for="settingQuizShuffle">Shuffle order</label>
                </div>
                <div class="form-check form-switch mb-0">
                  <input class="form-check-input" type="checkbox" id="settingQuizHideBestMoves">
                  <label class="form-check-label" for="settingQuizHideBestMoves">Hide best moves panel</label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" id="resetSettingsBtn">Reset defaults</button>
        <button type="button" class="btn btn-primary" id="applySettingsBtn" data-bs-dismiss="modal">Apply</button>
      </div>
    </div>
  </div>
</div>

<script>
const USERNAME = {{ session.username|tojson }};
const DEFAULT_THRESHOLD_CP = {{ threshold_cp or 100 }};
const ALL_MISTAKES_FROM_SERVER = {{ mistakes|tojson }};

const SETTINGS_STORAGE_KEY = `chess-analyzer:analysis-settings:v1:${USERNAME}`;
const DEFAULT_SETTINGS = {
  enableDrag: true,
  showCoords: true,
  highlightMoves: true,
  autoAdvance: true,
  acceptTopN: 1,
  minCp: DEFAULT_THRESHOLD_CP,
  minFreq: 1,
  quizMode: false,
  quizShuffle: true,
  quizHideBestMoves: true,
};

let settings = loadSettings();
let mistakesAll = Array.isArray(ALL_MISTAKES_FROM_SERVER) ? ALL_MISTAKES_FROM_SERVER.slice() : [];
let mistakesView = [];

let currentIndex = 0;
let board = null;
let game = null;
let flipped = false;
let selectedSquare = null;
let suppressInputUntil = 0;
let hintTimer = null;

const DEFAULT_BOARD_ORIENTATION = '{{ "black" if color == "black" else "white" }}';
const SQUARE_CLASS = 'square-55d63';

let quiz = {
  active: false,
  correct: 0,
  total: 0,
  solved: new Set(),
};

function toast(message, type = 'info') {
  if (typeof window.showToast === 'function') {
    window.showToast(message, type);
    return;
  }
  console.log(`[${type}] ${message}`);
}

function clampInt(value, min, max, fallback) {
  const n = Number.parseInt(value, 10);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.min(max, n));
}

function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function mistakeKey(m) {
  const color = m && m.color ? m.color : 'unknown';
  if (m && Number.isInteger(m.source_index)) return `${color}:${m.source_index}`;
  return `${color}:${m && m.fen ? m.fen : ''}`;
}

function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
    if (!raw) return { ...DEFAULT_SETTINGS };
    const parsed = JSON.parse(raw);
    return normalizeSettings(parsed);
  } catch {
    return { ...DEFAULT_SETTINGS };
  }
}

function saveSettings(next) {
  settings = normalizeSettings(next);
  localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
}

function normalizeSettings(s) {
  const next = { ...DEFAULT_SETTINGS, ...(s && typeof s === 'object' ? s : {}) };
  next.enableDrag = Boolean(next.enableDrag);
  next.showCoords = Boolean(next.showCoords);
  next.highlightMoves = Boolean(next.highlightMoves);
  next.autoAdvance = Boolean(next.autoAdvance);
  next.acceptTopN = clampInt(next.acceptTopN, 1, 5, DEFAULT_SETTINGS.acceptTopN);
  next.minCp = clampInt(next.minCp, 0, 9999, DEFAULT_SETTINGS.minCp);
  next.minFreq = clampInt(next.minFreq, 1, 9999, DEFAULT_SETTINGS.minFreq);
  next.quizMode = Boolean(next.quizMode);
  next.quizShuffle = Boolean(next.quizShuffle);
  next.quizHideBestMoves = Boolean(next.quizHideBestMoves);
  return next;
}

function getCurrentMistake() {
  return mistakesView[currentIndex];
}

function resetQuiz() {
  quiz = {
    active: Boolean(settings.quizMode),
    correct: 0,
    total: mistakesView.length,
    solved: new Set(),
  };
  updateQuizHud();
}

function updateModeUI() {
  const badge = document.getElementById('modeBadge');
  if (badge) {
    if (settings.quizMode) {
      badge.className = 'badge bg-primary';
      badge.textContent = 'Quiz';
    } else {
      badge.className = 'badge bg-info';
      badge.textContent = 'Trainer';
    }
  }

  const hud = document.getElementById('quizHud');
  if (hud) hud.classList.toggle('d-none', !settings.quizMode);

  const quizBtn = document.getElementById('quizToggleBtn');
  if (quizBtn) {
    quizBtn.classList.toggle('btn-outline-primary', !settings.quizMode);
    quizBtn.classList.toggle('btn-primary', settings.quizMode);
    quizBtn.textContent = settings.quizMode ? 'üß© Quiz: ON' : 'üß© Quiz';
  }

  updateBestMovesVisibility();
}

function updateQuizHud() {
  const totalEl = document.getElementById('quizTotal');
  const correctEl = document.getElementById('quizCorrect');
  if (totalEl) totalEl.textContent = String(quiz.total || mistakesView.length || 0);
  if (correctEl) correctEl.textContent = String(quiz.correct || 0);
}

function updateBestMovesVisibility() {
  const panel = document.querySelector('.best-moves-container');
  if (!panel) return;
  const hide = settings.quizMode && settings.quizHideBestMoves;
  panel.classList.toggle('d-none', hide);
}

function updateMistakeCount() {
  const el = document.getElementById('mistakeCount');
  if (el) el.textContent = String(mistakesView.length);
}

function computeViewMistakes() {
  const minCp = clampInt(settings.minCp, 0, 9999, DEFAULT_SETTINGS.minCp);
  const minFreq = clampInt(settings.minFreq, 1, 9999, DEFAULT_SETTINGS.minFreq);

  const filtered = mistakesAll.filter((m) => {
    const cp = Number(m.avg_cp_loss || 0);
    const freq = Number(m.pair_count || 1);
    return cp >= minCp && freq >= minFreq;
  });

  if (settings.quizMode) {
    if (settings.quizShuffle) shuffleInPlace(filtered);
    return filtered;
  }

  // Default order: higher CP loss first, then frequency
  filtered.sort((a, b) => (b.avg_cp_loss || 0) - (a.avg_cp_loss || 0) || (b.pair_count || 0) - (a.pair_count || 0));
  return filtered;
}

function rebuildView({ keepCurrent = true, resetQuizState = false } = {}) {
  const currentKey = keepCurrent ? mistakeKey(getCurrentMistake()) : null;
  mistakesView = computeViewMistakes();

  if (mistakesView.length === 0) {
    currentIndex = 0;
  } else if (currentKey) {
    const idx = mistakesView.findIndex((m) => mistakeKey(m) === currentKey);
    currentIndex = idx >= 0 ? idx : Math.min(currentIndex, mistakesView.length - 1);
  } else {
    currentIndex = Math.min(currentIndex, mistakesView.length - 1);
  }

  updateMistakeCount();
  buildMistakesTable();

  if (resetQuizState) resetQuiz();

  if (mistakesView.length > 0) {
    showPosition(currentIndex);
  } else {
    document.getElementById('posCounter').textContent = 'No positions';
    document.getElementById('bestMovesDisplay').innerHTML = '<span class="text-muted">No mistakes match your filters.</span>';
  }
}

function suppressInputFor(ms, opts = {}) {
  const { blockPointerEvents = false } = opts;
  suppressInputUntil = Math.max(suppressInputUntil, Date.now() + ms);
  if (!blockPointerEvents) return;

  const el = document.getElementById('board');
  if (!el) return;
  el.classList.add('board-blocked');
  setTimeout(() => {
    if (Date.now() >= suppressInputUntil) el.classList.remove('board-blocked');
  }, ms + 50);
}

function isInteractionSuppressed() {
  return Date.now() < suppressInputUntil;
}

function squareFromElement(el) {
  for (const cls of el.classList) {
    if (/^square-[a-h][1-8]$/.test(cls)) return cls.replace('square-', '');
  }
  return null;
}

function clearSquareClasses(classNames) {
  if (!classNames || classNames.length === 0) return;
  $('#board .' + SQUARE_CLASS).removeClass(classNames.join(' '));
}

function highlightSquare(square, className) {
  if (!square) return;
  $('#board .square-' + square).addClass(className);
}

function clearSelectionHighlights() {
  clearSquareClasses(['board-square-selected', 'board-square-legal', 'board-square-legal-capture']);
}

function clearHintHighlights() {
  clearSquareClasses(['board-square-hint']);
  if (hintTimer) {
    clearTimeout(hintTimer);
    hintTimer = null;
  }
}

function clearLastMoveHighlights() {
  clearSquareClasses(['board-square-lastmove']);
}

function clearAllHighlights() {
  clearSelectionHighlights();
  clearHintHighlights();
  clearLastMoveHighlights();
}

function setSelectedSquare(square) {
  if (!game) return;
  clearSelectionHighlights();
  selectedSquare = square;

  if (!settings.highlightMoves) return;

  highlightSquare(square, 'board-square-selected');

  const moves = game.moves({ square, verbose: true });
  moves.forEach((m) => {
    highlightSquare(m.to, m.captured ? 'board-square-legal-capture' : 'board-square-legal');
  });
}

function clearSelectedSquare() {
  selectedSquare = null;
  clearSelectionHighlights();
}

function updateBoardMeta(m) {
  const statusEl = document.getElementById('boardStatus');
  if (statusEl && game && m) {
    const toMove = game.turn() === 'w' ? 'White' : 'Black';
    const severity = m.avg_cp_loss >= 300 ? 'Severe' : m.avg_cp_loss >= 180 ? 'High' : 'Moderate';
    statusEl.textContent = `Side to move: ${toMove} ¬∑ CP loss: ${m.avg_cp_loss} (${severity}) ¬∑ Freq: ${m.pair_count || 1}`;
  }

  const lichessEl = document.getElementById('lichessLink');
  if (lichessEl && game) {
    lichessEl.href = `https://lichess.org/analysis/${game.fen().replace(/ /g, '_')}`;
  }
}

function isCorrectTrainingMove(move) {
  const m = getCurrentMistake();
  if (!m || !m.top_moves || m.top_moves.length === 0) return true;

  const n = clampInt(settings.acceptTopN, 1, 5, 1);
  const moveUci = (move.from + move.to + (move.promotion || '')).toLowerCase();
  const base = moveUci.slice(0, 4);
  return m.top_moves.slice(0, n).some((topMove) => (topMove || '').toLowerCase().startsWith(base));
}

function maybeFinishQuiz() {
  if (!settings.quizMode) return;
  if (mistakesView.length === 0) return;
  if (currentIndex < mistakesView.length - 1) return;
  toast(`Quiz complete! Score: ${quiz.correct}/${mistakesView.length}`, 'success');
}

function handleCorrectMove(move) {
  clearLastMoveHighlights();
  highlightSquare(move.from, 'board-square-lastmove');
  highlightSquare(move.to, 'board-square-lastmove');

  if (settings.quizMode) {
    const key = mistakeKey(getCurrentMistake());
    if (!quiz.solved.has(key)) {
      quiz.solved.add(key);
      quiz.correct += 1;
    }
    updateQuizHud();
  }

  updateBoardMeta(getCurrentMistake());
  toast('‚úÖ Correct!', 'success');

  suppressInputFor(900);

  if (settings.autoAdvance) {
    setTimeout(() => {
      if (currentIndex >= mistakesView.length - 1) {
        maybeFinishQuiz();
        return;
      }
      nextPosition();
    }, 800);
  }
}

function handleWrongMove() {
  clearLastMoveHighlights();
  clearSelectedSquare();
  toast('‚ùå Not the best move. Try again!', 'warning');
}

function attemptMove(from, to) {
  if (!game || isInteractionSuppressed()) return;

  clearHintHighlights();
  const move = game.move({ from, to, promotion: 'q' });
  if (!move) {
    toast('Illegal move.', 'warning');
    return;
  }

  if (!isCorrectTrainingMove(move)) {
    game.undo();
    board.position(game.fen(), true);
    handleWrongMove();
    return;
  }

  board.position(game.fen(), true);
  clearSelectedSquare();
  handleCorrectMove(move);
}

function destroyAndRecreateBoard() {
  if (board) {
    try { board.destroy(); } catch {}
    board = null;
  }

  game = new Chess();
  const config = {
    position: 'start',
    orientation: DEFAULT_BOARD_ORIENTATION,
    draggable: settings.enableDrag,
    showNotation: settings.showCoords,
    pieceTheme: '/assets/img/chesspieces/wikipedia/{piece}.png',
    onDragStart,
    onDrop,
    onSnapEnd,
  };

  board = ChessBoard('board', config);

  // Click/tap to move
  $('#board')
    .off('click.boardtap')
    .on('click.boardtap', '.' + SQUARE_CLASS, function() {
      if (!game || isInteractionSuppressed()) return;
      const square = squareFromElement(this);
      if (!square) return;

      if (Date.now() < suppressInputUntil) return;

      const piece = game.get(square);

      if (!selectedSquare) {
        if (!piece) return;
        if (piece.color !== game.turn()) return;
        setSelectedSquare(square);
        return;
      }

      if (square === selectedSquare) {
        clearSelectedSquare();
        return;
      }

      if (piece && piece.color === game.turn()) {
        setSelectedSquare(square);
        return;
      }

      attemptMove(selectedSquare, square);
    });

  $(window).off('resize.board').on('resize.board', function() {
    if (board) board.resize();
  });
}

function onDragStart(source, piece) {
  if (!settings.enableDrag) return false;
  if (isInteractionSuppressed()) return false;
  if (!game || game.game_over()) return false;

  if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
      (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
    return false;
  }

  suppressInputFor(250);
  setSelectedSquare(source);
}

function onDrop(source, target) {
  if (!settings.enableDrag) return 'snapback';
  if (!game) return 'snapback';
  if (isInteractionSuppressed()) return 'snapback';

  clearHintHighlights();

  if (target === 'offboard') {
    clearSelectedSquare();
    return 'snapback';
  }

  if (source === target) {
    setSelectedSquare(source);
    return 'snapback';
  }

  clearSelectedSquare();

  const move = game.move({ from: source, to: target, promotion: 'q' });
  if (move === null) return 'snapback';

  if (!isCorrectTrainingMove(move)) {
    game.undo();
    handleWrongMove();
    return 'snapback';
  }

  handleCorrectMove(move);
}

function onSnapEnd() {
  if (!board || !game) return;
  board.position(game.fen());
  updateBoardMeta(getCurrentMistake());
}

function showPosition(idx) {
  if (idx < 0 || idx >= mistakesView.length) return;
  currentIndex = idx;
  const m = mistakesView[idx];
  if (!m) return;

  clearAllHighlights();

  game = new Chess(m.fen);
  const orientation = m.color ? m.color : (game.turn() === 'w' ? 'white' : 'black');
  if (!flipped) board.orientation(orientation);
  board.position(m.fen, true);

  displayBestMoves(m);

  const posCounter = document.getElementById('posCounter');
  if (posCounter) posCounter.textContent = `Position ${idx + 1} of ${mistakesView.length}`;

  const btnFirst = document.getElementById('btnFirst');
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnLast = document.getElementById('btnLast');
  if (btnFirst) btnFirst.disabled = idx === 0;
  if (btnPrev) btnPrev.disabled = idx === 0;
  if (btnNext) btnNext.disabled = idx === mistakesView.length - 1;
  if (btnLast) btnLast.disabled = idx === mistakesView.length - 1;

  document.querySelectorAll('#mistakesTableBody tr[data-idx]').forEach((tr) => {
    tr.classList.toggle('table-active', Number(tr.getAttribute('data-idx')) === idx);
  });

  const activeRow = document.querySelector(`#mistakesTableBody tr.table-active`);
  if (activeRow) activeRow.scrollIntoView({ block: 'nearest' });

  updateBoardMeta(m);
}

function displayBestMoves(m) {
  const container = document.getElementById('bestMovesDisplay');
  if (!container) return;

  if (settings.quizMode && settings.quizHideBestMoves) {
    container.innerHTML = '<span class="text-muted">Hidden in quiz mode.</span>';
    return;
  }

  if (!m.top_moves || m.top_moves.length === 0) {
    container.innerHTML = '<span class="text-muted">No suggestions available</span>';
    return;
  }

  const moves = m.top_moves.slice(0, 3).map((uci, i) => {
    const tempGame = new Chess(m.fen);
    const move = tempGame.move({
      from: uci.slice(0, 2),
      to: uci.slice(2, 4),
      promotion: uci[4] || undefined
    });
    const san = move ? move.san : uci;
    const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : 'ü•â';
    return `<span class="best-move-badge" onclick="previewMove('${uci}')" title="Click to preview">${medal} ${san}</span>`;
  });

  container.innerHTML = moves.join('');
}

function previewMove(uci) {
  if (isInteractionSuppressed()) return;
  const m = getCurrentMistake();
  if (!m) return;

  const tempGame = new Chess(m.fen);
  const move = tempGame.move({
    from: uci.slice(0, 2),
    to: uci.slice(2, 4),
    promotion: uci[4] || undefined
  });

  if (!move) return;

  clearAllHighlights();
  highlightSquare(move.from, 'board-square-hint');
  highlightSquare(move.to, 'board-square-hint');

  suppressInputFor(1600, { blockPointerEvents: true });
  board.position(tempGame.fen(), true);
  setTimeout(() => {
    board.position(m.fen, true);
    clearHintHighlights();
  }, 1500);
}

function firstPosition() { showPosition(0); }
function prevPosition() { showPosition(currentIndex - 1); }
function nextPosition() { showPosition(currentIndex + 1); }
function lastPosition() { showPosition(mistakesView.length - 1); }

function flipBoardFunc() {
  flipped = !flipped;
  board.flip();
}

function resetPosition() {
  if (!mistakesView || mistakesView.length === 0) return;
  showPosition(currentIndex);
  toast('‚Ü© Position reset.', 'info');
}

function showHint() {
  const m = getCurrentMistake();
  if (!m || !m.top_moves || m.top_moves.length === 0) {
    toast('No hint available for this position.', 'info');
    return;
  }

  const bestUci = m.top_moves[0];
  const from = bestUci.slice(0, 2);
  const to = bestUci.slice(2, 4);
  const tempGame = new Chess(m.fen);
  const move = tempGame.move({ from, to, promotion: bestUci[4] || undefined });
  const label = move ? move.san : bestUci;

  clearHintHighlights();
  highlightSquare(from, 'board-square-hint');
  highlightSquare(to, 'board-square-hint');
  toast(`üí° Hint: ${label}`, 'info');

  hintTimer = setTimeout(() => {
    clearHintHighlights();
  }, 1800);
}

function copyFEN() {
  if (!game) return;
  const fen = game.fen();
  navigator.clipboard.writeText(fen).then(() => {
    toast('üìã FEN copied to clipboard!', 'success');
  }).catch(() => {
    prompt('Copy FEN:', fen);
  });
}

function showStats() {
  const list = mistakesView.length ? mistakesView : mistakesAll;
  const total = list.length;
  const severe = list.filter(m => m.avg_cp_loss >= 300).length;
  const high = list.filter(m => m.avg_cp_loss >= 180 && m.avg_cp_loss < 300).length;
  const moderate = total - severe - high;
  alert(`üìä Statistics\n\nTotal Mistakes: ${total}\nüî¥ Severe (300+ cp): ${severe}\nüü† High (180-299 cp): ${high}\nüü¢ Moderate (<180 cp): ${moderate}`);
}

function exportMistakes() {
  const data = JSON.stringify(mistakesView.length ? mistakesView : mistakesAll, null, 2);
  const blob = new Blob([data], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'mistakes.json';
  a.click();
  URL.revokeObjectURL(url);
  toast('üì§ Mistakes exported!', 'success');
}

function printMistakes() {
  window.print();
}

function buildMistakesTable() {
  const tbody = document.getElementById('mistakesTableBody');
  if (!tbody) return;
  tbody.innerHTML = '';

  if (!mistakesView || mistakesView.length === 0) {
    const row = document.createElement('tr');
    row.innerHTML = '<td colspan="6" class="text-muted p-3">No mistakes match your filters.</td>';
    tbody.appendChild(row);
    return;
  }

  mistakesView.forEach((m, i) => {
    const severity = m.avg_cp_loss >= 300
      ? '<span class="badge bg-danger">Severe</span>'
      : m.avg_cp_loss >= 180
        ? '<span class="badge bg-warning">High</span>'
        : '<span class="badge bg-info">Moderate</span>';

    const colorBadge = m.color === 'black'
      ? '<span class="badge bg-secondary">Black</span>'
      : '<span class="badge bg-secondary">White</span>';

    let userMoveLabel = m.user_move;
    try {
      userMoveLabel = m.user_move.slice(0, 2) + '-' + m.user_move.slice(2, 4);
    } catch {}

    const row = document.createElement('tr');
    row.style.cursor = 'pointer';
    row.setAttribute('data-idx', String(i));
    row.onclick = () => showPosition(i);
    row.innerHTML = `
      <td><strong>${i + 1}</strong></td>
      <td>${m.pair_count || 1}</td>
      <td><strong style="color: ${m.avg_cp_loss >= 300 ? 'var(--danger)' : m.avg_cp_loss >= 180 ? 'var(--warning)' : 'var(--success)'}">${m.avg_cp_loss}</strong></td>
      <td><code>${userMoveLabel}</code> ${colorBadge}</td>
      <td>${severity}</td>
      <td>
        <button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="event.stopPropagation(); openLichess(${i})" title="Analyze on Lichess">üîó</button>
        <button class="btn btn-outline-danger btn-sm py-0 px-2 ms-1" onclick="event.stopPropagation(); deleteMistakeAt(${i})" title="Remove from queue">‚úÖ</button>
      </td>
    `;
    tbody.appendChild(row);
  });
}

function openLichess(idx) {
  const m = mistakesView[idx];
  if (!m || !m.fen) return;
  const url = `https://lichess.org/analysis/${m.fen.replace(/ /g, '_')}`;
  window.open(url, '_blank', 'noopener');
}

function deleteMistakeAt(idx) {
  showPosition(idx);
  deleteCurrentMistake();
}

function toggleQuizMode() {
  const next = { ...settings, quizMode: !settings.quizMode };
  saveSettings(next);
  updateModeUI();
  rebuildView({ keepCurrent: false, resetQuizState: true });
}

async function deleteCurrentMistake() {
  const m = getCurrentMistake();
  if (!m || !m.color || !Number.isInteger(m.source_index)) {
    toast('Cannot delete: missing source index for this mistake.', 'danger');
    return;
  }

  const ok = window.confirm('Remove this mistake from your queue?');
  if (!ok) return;

  try {
    const resp = await fetch(`/delete_mistake/${m.color}/${m.source_index}`, { method: 'POST' });
    const data = await resp.json();
    if (!resp.ok || !data || data.error) {
      toast(data && data.error ? data.error : 'Failed to delete mistake.', 'danger');
      return;
    }

    // Remove from local arrays and reindex subsequent source_index values for that color.
    const deletedIndex = m.source_index;
    const deletedColor = m.color;
    mistakesAll = mistakesAll
      .filter((x) => !(x.color === deletedColor && x.source_index === deletedIndex))
      .map((x) => {
        if (x.color === deletedColor && Number.isInteger(x.source_index) && x.source_index > deletedIndex) {
          return { ...x, source_index: x.source_index - 1 };
        }
        return x;
      });

    toast('‚úÖ Removed from your queue.', 'success');
    rebuildView({ keepCurrent: false, resetQuizState: settings.quizMode });
  } catch {
    toast('Failed to delete mistake.', 'danger');
  }
}

function applySettingsFromModal() {
  const next = {
    ...settings,
    enableDrag: Boolean(document.getElementById('settingEnableDrag')?.checked),
    showCoords: Boolean(document.getElementById('settingShowCoords')?.checked),
    highlightMoves: Boolean(document.getElementById('settingHighlightMoves')?.checked),
    autoAdvance: Boolean(document.getElementById('settingAutoAdvance')?.checked),
    acceptTopN: clampInt(document.getElementById('settingAcceptTopN')?.value, 1, 5, DEFAULT_SETTINGS.acceptTopN),
    minCp: clampInt(document.getElementById('settingMinCp')?.value, 0, 9999, DEFAULT_SETTINGS.minCp),
    minFreq: clampInt(document.getElementById('settingMinFreq')?.value, 1, 9999, DEFAULT_SETTINGS.minFreq),
    quizMode: Boolean(document.getElementById('settingQuizMode')?.checked),
    quizShuffle: Boolean(document.getElementById('settingQuizShuffle')?.checked),
    quizHideBestMoves: Boolean(document.getElementById('settingQuizHideBestMoves')?.checked),
  };

  const old = settings;
  saveSettings(next);

  // Recreate board if board-specific settings changed.
  const boardNeedsReinit = old.enableDrag !== settings.enableDrag || old.showCoords !== settings.showCoords;
  if (boardNeedsReinit) destroyAndRecreateBoard();

  updateModeUI();
  rebuildView({ keepCurrent: true, resetQuizState: old.quizMode !== settings.quizMode });
}

function resetSettingsToDefaults() {
  saveSettings({ ...DEFAULT_SETTINGS });
  syncSettingsModal();
  destroyAndRecreateBoard();
  updateModeUI();
  rebuildView({ keepCurrent: false, resetQuizState: true });
  toast('Settings reset to defaults.', 'info');
}

function syncSettingsModal() {
  const drag = document.getElementById('settingEnableDrag');
  const coords = document.getElementById('settingShowCoords');
  const hl = document.getElementById('settingHighlightMoves');
  const adv = document.getElementById('settingAutoAdvance');
  const topN = document.getElementById('settingAcceptTopN');
  const minCp = document.getElementById('settingMinCp');
  const minFreq = document.getElementById('settingMinFreq');
  const quizMode = document.getElementById('settingQuizMode');
  const quizShuffle = document.getElementById('settingQuizShuffle');
  const quizHide = document.getElementById('settingQuizHideBestMoves');

  if (drag) drag.checked = settings.enableDrag;
  if (coords) coords.checked = settings.showCoords;
  if (hl) hl.checked = settings.highlightMoves;
  if (adv) adv.checked = settings.autoAdvance;
  if (topN) topN.value = String(settings.acceptTopN);
  if (minCp) minCp.value = String(settings.minCp);
  if (minFreq) minFreq.value = String(settings.minFreq);
  if (quizMode) quizMode.checked = settings.quizMode;
  if (quizShuffle) quizShuffle.checked = settings.quizShuffle;
  if (quizHide) quizHide.checked = settings.quizHideBestMoves;
}

// Initialize
$(document).ready(function() {
  destroyAndRecreateBoard();
  updateModeUI();
  rebuildView({ keepCurrent: false, resetQuizState: true });
  syncSettingsModal();

  document.getElementById('applySettingsBtn')?.addEventListener('click', applySettingsFromModal);
  document.getElementById('resetSettingsBtn')?.addEventListener('click', resetSettingsToDefaults);

  // Keep modal in sync when opened (Bootstrap triggers this custom event)
  document.getElementById('settingsModal')?.addEventListener('show.bs.modal', syncSettingsModal);

  // Click anywhere outside the board to clear selection/hints
  $(document)
    .off('click.boardoutside')
    .on('click.boardoutside', function(e) {
      if ($(e.target).closest('#board').length) return;
      clearSelectedSquare();
      clearHintHighlights();
    });
});

// Keyboard shortcuts
$(document).keydown(function(e) {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  if ($(e.target).closest('.modal').length) return;

  switch(e.key) {
    case 'ArrowLeft': prevPosition(); e.preventDefault(); break;
    case 'ArrowRight': nextPosition(); e.preventDefault(); break;
    case 'Home': firstPosition(); e.preventDefault(); break;
    case 'End': lastPosition(); e.preventDefault(); break;
    case 'f': case 'F': flipBoardFunc(); break;
    case 'h': case 'H': showHint(); break;
    case 'r': case 'R': resetPosition(); break;
    case 'c': case 'C': copyFEN(); break;
    case 'l': case 'L': {
      if (game) window.open(`https://lichess.org/analysis/${game.fen().replace(/ /g, '_')}`, '_blank');
      break;
    }
    case 'Escape': clearSelectedSquare(); clearHintHighlights(); break;
  }
});
</script>

{% endif %}

{% endblock %}
